# User-Chain

Each user has a user-chain to determine the ownership of devices. The chain is supposed to be immutable. Items can't be reordered and no forks are allowed. In case a fork is dedected the chain is considered invalid.

Different clients will do/can do different validations based on their capabilities. On a with a secure storage the chain for each workspace is stored in a the secure storage. The idea is that the client only asks the server only for new chain items and verifies that these are valid. In case an invalid item would appear an exception is thrown, the user informed and the entiry workspace should go into a read-only mode. Currently neither Desktop nor Mobile clients have have this implemented and store the user-chain in a secure storage.

If no secure storage is available e.g. in a web client the full user-chain per user is downloaded and processed when necessary. This means a web client can't dedect a fork. See exmaples where the user-chains reconstructed are used:

- https://github.com/serenity-kit/Serenity/blob/main/apps/app/utils/workspace/rotateWorkspaceKey.ts (rotating the workspace key)
- https://github.com/serenity-kit/Serenity/blob/main/apps/app/components/page/Page.tsx#L358-L365 (verifying a document change)
- https://github.com/serenity-kit/Serenity/blob/main/apps/app/components/createWorkspaceForm/CreateWorkspaceForm.tsx#L88-L111 (getting all user device before creating a workspace)
  - https://github.com/serenity-kit/Serenity/blob/main/apps/app/store/userChainStore.ts#L290

In the future a client without a secure storage could store the last chain event hash and verify that it's part of the chain. If these hashes get leaked there is some meta-data leaked but it doesn't result in leaking of encrypted content. There is a trade-off between verifying the chain and leaking meta-data.

## Structure

The chain is a series of events where each event contains a

- transaction
  - type
  - version
  - previous event hash
  - … custom props depending on the type
- author
  - publicKey
  - signature of the combined transaction hash and the previous transaction hash

https://github.com/serenity-kit/Serenity/tree/main/packages/user-chain/src

Based on the user-chain a current state of a user including all theirs devices can be derived.

## Cryptographic Dependencies and actual implementation

- generate_id: `sodium.to_base64(sodium.randombytes_buf(24))`
- hash: `sodium.to_base64(sodium.crypto_generichash(64, message))`
- canonicalize: predictable canonicalization of JSON as defined by RFC8785 https://www.npmjs.com/package/canonicalize
- sign: `sodium.crypto_sign_detached(message, privateKey)`
- signVerify: `sodium.crypto_sign_detached(signature, message, publicKey)`

## Available Transaction Types

- createUserChain
- addDevice
- removeDevice

## Device structure

- signingPublicKey
- encryptionPublicKey
- encryptionPublicKeySignature (context prefix: `user_device_encryption_public_key`)

## Overview of state after a chain has been processed

- id
- email
- mainDeviceSigningPublicKey
- mainDeviceEncryptionPublicKey
- mainDeviceEncryptionPublicKeySignature
- devices
- removedDevices
- eventHash
- eventVersion // for protocol versioning

## Creating any chain event

```ts
transaction = {
  prevEventHash, // is null for the createChain event
  …
}
transactionHash = hash(canonicalize(transaction));
signature = sign(concat("user_chain", transactionHash), privateKey);
```

## Cryptographic validation for all chain events

```ts
transactionHash = hash(canonicalize(transaction));
signVerify(
  author.signature,
  concat("user_chain", transactionHash),
  author.publicKey
);
```

This allows to validate:

- the transaction is authenticated by the author
- the transaction is not modified

For the createChain event the prevEventHash is null. For all other events it must be defined. Once provided it results in the following properties:

- the previousEventHash is authenticated by the author
- the previousEventHash is not modified

## Transaction Types and Validations

### Create chain

```ts
encryptionPublicKeySignature = sign(
  concat("user_device_encryption_public_key", encryptionPublicKey),
  signingPrivateKey
);
transaction = {
  type: "create",
  id: generateId(),
  encryptionPublicKey,
  encryptionPublicKeySignature,
  prevEventHash: null,
  email,
  version,
};
```

The `id` is to identify the user by ID.

https://github.com/serenity-kit/Serenity/blob/main/packages/user-chain/src/createUserChain.ts

Validations:

- has a signingPublicKey, encryptionPublicKey and valid encryptionPublicKeySignature for the main device

```ts
signVerify(
  encryptionPublicKeySignature,
  concat("user_device_encryption_public_key", encryptionPublicKey),
  signingPublicKey
);
```

https://github.com/serenity-kit/Serenity/blob/main/packages/user-chain/src/applyCreateUserChainEvent.ts

### Add Device

Adds a device to the user. `signingPublicKey` & `encryptionPublicKey` are required parameters, while `expiresAt` is optional. The idea behind expiresAt is that you can add short lived devices and each client, but also the server can check that expired devices are not included in e.g. workspace key rotations.

In order to prevent drifts between clients the device session for example expires earlier than the expiredAt.

In addition the signing private key is used to sign the prevEventHash. This allows to verify that the user adding the device even has access to the private key of the device that is being added. Otherwise the user could add a device that is not theirs. There is no value in doing so as a user, but does not hurt to prevent it.

```ts
deviceSigningContent = canonicalize(
  userDeviceSigningKeyProofDomainContext,
  prevEventHash
);
deviceSigningKeyProof = sign(
  concat("user_device_signing_key_proof", deviceSigningContent),
  deviceSigningPrivateKey
);
```

https://github.com/serenity-kit/Serenity/blob/main/packages/user-chain/src/addDevice.ts

Validations:

- the device does not exist in the state derived until the event
- has a signingPublicKey, encryptionPublicKey and valid encryptionPublicKeySignature

```ts
signVerify(
  encryptionPublicKeySignature,
  concat("user_device_encryption_public_key", encryptionPublicKey),
  signingPublicKey
);
```

- deviceSigningKeyProof is valid

```ts
signVerify(
  deviceSigningKeyProof,
  concat("user_device_signing_key_proof", deviceSigningContent),
  deviceSigningPublicKey
);
```

https://github.com/serenity-kit/Serenity/blob/main/packages/user-chain/src/applyEvent.ts#L57-L82

### Remove Device

Removes a device based on the provided `signingPublicKey`

https://github.com/serenity-kit/Serenity/blob/main/packages/user-chain/src/removeDevice.ts

Validations:

- the device does exist in the state derived until the event
- it's not the main device that is being removed

https://github.com/serenity-kit/Serenity/blob/main/packages/user-chain/src/applyEvent.ts#L84-L103

## Versioning

Each transaction includes a version of the protocol. Once the version has been increased by one transaction it can't go lower anymore. This means every client must have the same or a higher version than the last transaction in the chain otherwise the chain is considered invalid.

It also fails in case the version is higher than the currently known to prevent the chain being processed by an older client.

https://github.com/serenity-kit/Serenity/blob/main/packages/user-chain/src/applyEvent.ts#L38-L49

### Server Checks

When resolving the state on the backend also the knownVersion has to passed in. This ensures are client doesn't send a chain with a higher version than the server knows.

## Miscellaneous

All types are documented here: https://github.com/serenity-kit/Serenity/blob/main/packages/user-chain/src/types.ts

## Proposed Modifications

The following is a proposal to modify the above spec with the following key goals:

- **Excluding Web Logins from the Chain**: It is suggested that web logins should not be recorded on the user-chain. This approach aims to prevent the chain from becoming excessively long due to frequent browser logins.
- **Validation of Web Login Changes**: To validate changes made by a user via a web login, a method similar to Apple's end-to-end encryption for iCloud. The process involves using a device already on the user-chain to authorize web sessions.

### Ephemeral Keys for Browser Sessions

When a user logs into the web client (like iCloud.com), the browser requests authorization from a user’s device (like an iPhone) already on the user-chain.
The authorizing device sends a set of ephemeral keys, signed with its user-chain keys, to the browser. These keys have an expiration date, suggested to be around 30 days (`BROWSER_SESSION_LENGTH`).

The keys are transferred securely, potentially using a QR code scan or a similar secure method to prevent Man-in-the-Middle attacks.

The Serenity Notes server acts as a middle-man during the ephemeral key transfer, ensuring secure communication between the browser and the authorizing device.

### Expiration and Chain Integrity

The ephemeral keys, being temporary, are not stored on the user-chain, preserving the chain's integrity and preventing length explosion.
The user-chain, however, stores the configuration value `BROWSER_SESSION_LENGTH`, which is used by the Serenity server and other clients to determine the validity period of the ephemeral keys.

### User Experience Considerations

While this approach adds a step to the login process, it is likened to experiences users have with second-factor authentication systems. The balance between security and convenience is considered, with the suggestion to set the default expiration of the ephemeral keys to 30 days.

### Implementation and Impact
This proposal would require substantial changes to the current implementation of the user-chain, particularly in how web logins are handled. It introduces a more dynamic and secure method of handling browser sessions, aligning with modern security practices like those employed by Apple.

Integrating this proposal into the user-chain system underlines a commitment to security and user convenience. It emphasizes the importance of flexible, yet robust, security mechanisms in managing digital identities and device authentications, especially in a web context.

### Key Components and Process 

#### Ephemeral Key Generation
When a user attempts to log in via a web browser, the system triggers a request for authorization from a device already on the user-chain (e.g., a smartphone).
The authorized device generates a set of ephemeral keys, including a signing key and possibly a Diffie-Hellman (DH) key, for the web session. These keys are temporary and have an expiration date.
The generation uses cryptographic functions consistent with the user-chain system, like sodium.crypto_sign_detached for signing.

#### Key Signing
The ephemeral keys are signed using the private key of the authorizing device, which is already part of the user-chain.
This ensures that the ephemeral keys can be linked back to a device that is verifiably part of the user's secure environment.

#### Secure Key Transfer
The transfer of ephemeral keys from the authorizing device to the web browser should be secured against Man-in-the-Middle (MitM) attacks.
Implement a secure channel, potentially using QR codes or a secure web socket, facilitated by the Serenity server as a trustworthy intermediary.
The transfer might involve a DH key exchange for an additional layer of security.

#### Key Expiration and Renewal
Ephemeral keys expire after a predefined duration of `BROWSER_SESSION_LENGTH`, which could be set to 30 days by default.
Upon expiration, the user must re-authorize their web session through the same process to continue accessing their account via the browser.

#### Integration with User-Chain
The user-chain stores the `BROWSER_SESSION_LENGTH` configuration but does not store the ephemeral keys themselves, thus avoiding chain length explosion.
The chain’s integrity is maintained as the ephemeral keys are indirectly authenticated via the signing device’s keys, which are part of the user-chain.

#### Validation of Web Session Actions
Actions taken during the web session are validated using the ephemeral keys.
The system checks whether the keys are within their valid time frame and correctly signed by a device on the user-chain.

#### Compatibility and Versioning
- Ensure that the implementation of this ephemeral key system is compatible with the existing user-chain protocol, including handling versioning effectively.
- Update the client and server software to understand and correctly process these new types of key authorization and validation events.

#### Considerations for Implementation
- **Security**: Rigorously test the security of the ephemeral key generation, transfer, and validation processes to prevent any vulnerabilities.
- **User Experience**: Balance security with user convenience. The process should be intuitive and not overly burdensome for the user.
- **Documentation and Transparency**: Clearly document the changes and the reasons behind them for transparency and ease of understanding for all stakeholders.
- **Compliance and Legal Considerations**: Ensure that the implementation complies with relevant data protection and privacy laws.